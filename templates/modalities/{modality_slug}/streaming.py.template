"""{Modality} streaming primitives."""

from abc import abstractmethod
from collections.abc import AsyncIterator, Callable
from typing import Any, Unpack

from celeste.client import ModalityClient
from celeste.streaming import Stream

from .io import (
    {Modality}Chunk,
    {Modality}FinishReason,
    {Modality}Output,
    {Modality}Usage,
)
from .parameters import {Modality}Parameters


class {Modality}Stream(Stream[{Modality}Output, {Modality}Parameters, {Modality}Chunk]):
    """Streaming for {modality} modality."""

    def __init__(
        self,
        sse_iterator: AsyncIterator[dict[str, Any]],
        transform_output: Callable[..., {Content}],
        client: ModalityClient,
        **parameters: Unpack[{Modality}Parameters],
    ) -> None:
        super().__init__(sse_iterator, **parameters)
        self._transform_output = transform_output
        self._client = client

    @abstractmethod
    def _aggregate_content(self, chunks: list[{Modality}Chunk]) -> Any:
        """Aggregate content from chunks into raw content (modality-specific)."""
        ...

    def _aggregate_usage(self, chunks: list[{Modality}Chunk]) -> {Modality}Usage:
        """Aggregate usage across chunks (universal)."""
        for chunk in reversed(chunks):
            if chunk.usage:
                return chunk.usage
        return {Modality}Usage()

    def _aggregate_finish_reason(
        self,
        chunks: list[{Modality}Chunk],
    ) -> {Modality}FinishReason | None:
        """Aggregate finish reason across chunks (universal)."""
        for chunk in reversed(chunks):
            if chunk.finish_reason:
                return chunk.finish_reason
        return None

    @abstractmethod
    def _aggregate_event_data(self, chunks: list[{Modality}Chunk]) -> list[dict[str, Any]]:
        """Collect raw events (filtering happens in _build_stream_metadata)."""
        ...

    def _build_stream_metadata(
        self, raw_events: list[dict[str, Any]]
    ) -> dict[str, Any]:
        """Build streaming metadata. Provider API Stream overrides to filter content."""
        return {
            "model": self._client.model.id,
            "provider": self._client.provider,
            "modality": self._client.modality,
            "raw_events": raw_events,
        }

    def _parse_output(  # type: ignore[override]
        self,
        chunks: list[{Modality}Chunk],
        **parameters: Unpack[{Modality}Parameters],
    ) -> {Modality}Output:
        """Assemble chunks into final output."""
        raw_content = self._aggregate_content(chunks)
        content: {Content} = self._transform_output(raw_content, **parameters)
        raw_events = self._aggregate_event_data(chunks)
        return {Modality}Output(
            content=content,
            usage=self._aggregate_usage(chunks),
            finish_reason=self._aggregate_finish_reason(chunks),
            metadata=self._build_stream_metadata(raw_events),
        )


__all__ = ["{Modality}Stream"]
