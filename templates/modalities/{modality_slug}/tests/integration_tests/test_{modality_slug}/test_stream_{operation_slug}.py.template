"""Integration tests for streaming {modality} {operation}."""

# TODO: REMOVE - See test_{operation}.py for cost guidance on cheap vs expensive modalities.

import warnings

# Suppress deprecation warnings from legacy capability packages
warnings.filterwarnings(
    "ignore",
    message=".*capability parameter is deprecated.*",
    category=DeprecationWarning,
)

import pytest  # noqa: E402

from celeste import (  # noqa: E402
    Modality,
    Model,
    Operation,
    create_client,
    list_models,
)
from celeste.modalities.{modality} import {Modality}Chunk, {Modality}Usage  # noqa: E402


@pytest.mark.parametrize(
    "model",
    [
        m
        for m in list_models(modality=Modality.{MODALITY}, operation=Operation.{OPERATION})
        if m.streaming
        and not m.optional_input_types  # Media-capable models tested in test_stream_*_analyze_*
    ],
    ids=lambda m: f"{m.provider.value}-{m.id}",
)
@pytest.mark.integration
@pytest.mark.asyncio
async def test_stream_{operation}(model: Model) -> None:
    """Test streaming {modality} {operation} for all streaming-capable models.

    Dynamically discovers all streaming models and verifies each can stream.
    Failures indicate deprecated or misconfigured models.
    """
    client = create_client(
        modality=Modality.{MODALITY},
        model=model,
    )

    chunks: list[{Modality}Chunk] = []
    async for chunk in client.stream.{operation}(prompt="Hello"):
        chunks.append(chunk)

    # Assert - received at least one chunk
    assert chunks, f"Model {model.provider.value}/{model.id} returned no chunks"

    # Assert - all chunks are valid type
    assert all(isinstance(c, {Modality}Chunk) for c in chunks), (
        "All chunks should be {Modality}Chunk"
    )

    # Assert - usage in final chunks (provider-dependent)
    usage_chunks = [c for c in chunks if c.usage is not None]
    if usage_chunks:
        usage = usage_chunks[-1].usage
        assert isinstance(usage, {Modality}Usage), f"Expected {Modality}Usage, got {type(usage)}"


@pytest.mark.integration
def test_sync_stream_{operation}() -> None:
    """Test sync streaming wrapper works correctly.

    Single model smoke test - sync stream iteration bridges async internally.
    """
    models = [
        m
        for m in list_models(modality=Modality.{MODALITY}, operation=Operation.{OPERATION})
        if m.streaming and not m.optional_input_types
    ]
    model = models[0]

    client = create_client(
        modality=Modality.{MODALITY},
        model=model,
    )

    for chunk in client.sync.stream.{operation}(prompt="Hello"):
        pass  # Just exhaust the stream
